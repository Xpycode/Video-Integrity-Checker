# Session: 2026-02-26

## Goal
Implement MXF OP1a container inspector — shallow parse for broadcast pipeline diagnostics.

## Context
- Previous session: [2026-02-25](2026-02-25.md) — full implementation + ISOBMFF container inspection
- Current phase: implementation

## Progress

### Completed
- [x] Replaced MXF stub with full shallow-parse inspector (~370 lines)
- [x] KLV reader: 16-byte SMPTE key + BER length decoding (short + long form)
- [x] Partition pack parser: kind, status, chain offsets, KAG, OP UL, essence container UL batch
- [x] RIP (Random Index Pack) parser from EOF — partition offset discovery
- [x] Jump-based partition discovery: header at byte 0 → RIP → jump to each offset (never walks essence)
- [x] Index table segment scanning within each partition's declared index area
- [x] 5 validation checks: partition structure, OP1a conformance, index tables, RIP integrity, truncation
- [x] Codec identification from MXF-GC essence container ULs (AVC-Intra, MPEG-2, DNxHD, HEVC, etc.)
- [x] Clean build, zero warnings, Swift 6 strict concurrency

### Decisions Made
- **Shallow parse first** — partition packs, index tables, RIP, codec IDs. Deep metadata graph (Preface/ContentStorage/Packages) deferred until we have real MXF files to test against.
- **Jump-based approach** — read header at offset 0 + RIP from EOF, jump to partition offsets. Avoids walking through potentially gigabytes of interleaved essence data.
- **Memory-mapped I/O** — `Data(contentsOf:options:.mappedIfSafe)` consistent with ISOBMFF inspector.

### Discovered
- MXF BER length encoding: `0x83` = 3 following bytes (up to 16MB), `0x84` = 4 bytes (up to 4GB). Different from ISOBMFF's fixed-width size fields.
- Partition pack fixed fields are 88 bytes minimum before the essence container UL batch.
- RIP is read from EOF: last 4 bytes = total RIP length, then read backwards that many bytes.
- KAG (KLV Alignment Grid) alignment affects where KLVs start within partitions — handled in index table scanning.

### Bug Fix: ISOBMFF crash on truncated files
- [x] Diagnosed crash from crash report — `EXC_BREAKPOINT` in `parseBoxes` at line 152
- [x] Root cause: `Data` subscript out-of-bounds when box declares size larger than actual file data
- [x] Fix: clamp all end offsets to `min(end, UInt64(data.count))` in `parseBoxes` and all atom parsers
- [x] Bonus: moved `isContainerBox` Set to `static let` — was allocating/deallocating a heap Set per call
- [x] Verified fix: app opens and analyzes previously-crashing clips without issue

## Decisions
- **Defensive bounds clamping** — all ISOBMFF parsing functions now clamp declared box sizes against actual `data.count`. Untrusted size fields from corrupt files can no longer cause out-of-bounds access.

---

### Session 2 — Enhanced Container Validation (Corruption Research)

## Goal
Implement deep validation checks derived from corruption research — sample table cross-validation, NAL unit boundary parsing, and MXF integrity enhancements.

## Progress

### Wave 1: ISOBMFF Sample Table Cross-Validation
- [x] `parseSTCO` — chunk offset table (stco + co64 for large files)
- [x] `parseSTSC` — sample-to-chunk mapping table
- [x] `parseSTSZ` — per-sample size table (uniform + variable)
- [x] `validateSampleTables` — 6 cross-validation checks:
  - Chunk offsets within mdat bounds (catches truncated downloads)
  - Keyframe indices within valid sample range
  - Total sample bytes vs mdat payload size
  - First video sample is a keyframe
  - Zero-size sample detection
  - Monotonic chunk offset ordering

### Wave 2: NAL Unit Boundary Validation
- [x] `parseCodecConfig` — extract NAL length size from avcC (H.264) / hvcC (H.265) boxes
- [x] `buildFrameMap` — compute absolute byte offset + size for each sample from stco+stsc+stsz
- [x] `selectFramesToCheck` — configurable sampling by InspectionDepth (quick/standard/thorough)
- [x] `validateNALBoundaries` — walk NAL units within sampled frames, 4 checks:
  - NAL length overflow (declared > remaining bytes in frame)
  - Frame size mismatch (leftover bytes after all NALs parsed)
  - Keyframe IDR NAL type validation (H.264 type 5, H.265 types 16-21)
  - First sample IDR presence check

### Wave 3: MXF Enhanced Validation
- [x] `validateKLVIntegrity` — KLV length overflow detection in partition metadata/index areas
- [x] Enhanced footer validation — severity upgraded to `.error` for Closed & Complete files
- [x] Footer offset agreement check across all partitions
- [x] `validateEssenceConsistency` — header vs body partition essence container UL comparison
- [x] KAG alignment check for partition pack byte offsets

### Wave 4: Infrastructure
- [x] `InspectionDepth` enum (quick/standard/thorough) controlling validation scope
- [x] `playerNotes: String?` field on `ContainerDiagnostic` for player-specific context
- [x] New `DiagnosticCategory` cases: `.sampleTable`, `.nalStructure`
- [x] Updated `toMediaIssue()` to include player notes in descriptions
- [x] Updated protocol signature with `depth:` parameter (backward-compatible default)

### Decisions Made
- **InspectionDepth as protocol parameter** — allows caller to trade speed for thoroughness. `.standard` is default; future UI preference can expose this.
- **NAL sampling strategy** — first 5 frames + keyframes + evenly-spaced samples, capped at ~200 for `.standard`. Keeps inspection fast for multi-GB files.
- **Player notes as metadata, not UI** — `playerNotes` flows through `toMediaIssue()` into description text. Future UI can display distinctly.

## Decisions
- **Sample table cross-validation catches truncated downloads** — the most common real-world corruption where moov index references data beyond mdat. This was the highest-impact addition.
- **NAL validation is sampling-based** — checking every frame would be too slow for large files. Keyframes are prioritized because corruption there cascades through dependent frames.

## Next Session
- Test with real MXF files (OP1a from AME export, broadcast ingest files)
- Smoke test: truncated MP4 (`head -c 50% file.mp4`) to verify sample table overflow detection
- Dual-engine cross-reference (AVFoundation vs ffmpeg comparison)
- Vision framework artifact detection (green frames, macroblocking)
- Unit tests for container inspection (ISOBMFF + MXF)
- Consider exposing InspectionDepth in UI preferences

## Notes
- 4 files changed, ~1,400 lines added. No new files — all additions to existing inspectors.
- All SourceKit "cannot find type" warnings are cross-file resolution noise, not real errors. Build succeeds cleanly.
- Player notes added for 6 diagnostic types covering VLC/QuickTime/AVFoundation/Avid/DaVinci Resolve behavior differences.

---

### Session 3 — Corruption Taxonomy Reference + Tier 1 Gap Closure

## Goal
Save comprehensive corruption reference document and implement highest-value detection gaps identified by coverage audit.

## Context
- User provided detailed corruption taxonomy covering MP4/MOV (A-E), MXF (F-I), bitstream (BS/AS), and storage (ST) categories
- Coverage audit revealed ~45% detection coverage (30 detected, 10 partial, 33 gaps)

## Progress

### Audit & Reference
- [x] Ran full coverage audit mapping 73 corruption types against current inspectors
- [x] Saved reference as `docs/corruption-taxonomy.md` with structure diagrams, detection strategies, repair approaches, and live coverage map
- [x] Identified Tier 1 (quick wins), Tier 2 (professional), Tier 3 (deep forensics) priorities

### Tier 1 Implementation — 14 new diagnostics

**B6: stts/ctts Timing Table Validation** (4 checks)
- [x] Zero duration samples (delta=0 → non-monotonic DTS)
- [x] Abnormal frame durations (>10s per frame at track timescale)
- [x] stts vs stsz sample count mismatch
- [x] ctts count mismatch + extreme composition offsets (>5s)

**A4: Invalid Box Sizes** (3 checks)
- [x] Box size < 8 bytes (impossible — below header minimum)
- [x] Box extends beyond EOF (per-box truncation)
- [x] Overlapping boxes (adjacent box byte ranges collide)

**BS2: SPS/PPS Presence Validation** (6 checks)
- [x] avcC: truncated box, missing SPS (count=0), missing PPS (count=0)
- [x] hvcC: truncated box, missing VPS/SPS/PPS (NAL types 32/33/34)

**B3: stco Overflow Detection** (1 check)
- [x] 32-bit stco on >4GB files (offset wraparound detection)

### Build
- [x] Clean build, zero errors

### Decisions Made
- **Timing validation runs on all tracks, not just video** — audio timing corruption causes A/V desync too
- **SPS/PPS validation runs even at quick depth** — it's a metadata check (no mdat reading), and missing parameter sets means total unplayability
- **stco overflow is remediation: `.remux`** — converting stco→co64 only requires container rewrite, not re-encoding

## Next Session
- Test with real corrupt files (truncated MP4, files >4GB with stco)
- Tier 2: Fragmented MP4 (moof/mdat parsing) — increasingly common
- Tier 2: MXF metadata depth (Preface, packages, timecode)
- Dual-engine cross-reference (AVFoundation vs ffmpeg comparison)
- Unit tests for container inspection
